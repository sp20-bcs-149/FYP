{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport parseErrorStack from \"../../Core/Devtools/parseErrorStack\";\nimport UTFSequence from \"../../UTFSequence\";\nimport stringifySafe from \"../../Utilities/stringifySafe\";\nimport ansiRegex from 'ansi-regex';\nvar ANSI_REGEX = ansiRegex().source;\nvar BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nvar BABEL_CODE_FRAME_MARKER_PATTERN = new RegExp(['^', \"(?:\" + ANSI_REGEX + \")*\", '>', \"(?:\" + ANSI_REGEX + \")*\", ' +', '[0-9]+', ' \\\\|'].join(''), 'm');\nvar BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*):? (?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)(\\/(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+?)\\n([ >]{2}[\\t-\\r 0-9\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+ \\|(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|\\x1B(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*) \\(([0-9]+):([0-9]+)\\)\\n\\n((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar SUBSTITUTION = UTFSequence.BOM + '%s';\nexport function parseInterpolation(args) {\n  var categoryParts = [];\n  var contentParts = [];\n  var substitutionOffsets = [];\n  var remaining = _toConsumableArray(args);\n  if (typeof remaining[0] === 'string') {\n    var formatString = String(remaining.shift());\n    var formatStringParts = formatString.split('%s');\n    var substitutionCount = formatStringParts.length - 1;\n    var substitutions = remaining.splice(0, substitutionCount);\n    var categoryString = '';\n    var contentString = '';\n    var substitutionIndex = 0;\n    for (var formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          var substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length\n          });\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length\n          });\n          categoryString += '%s';\n          contentString += '%s';\n        }\n        substitutionIndex++;\n      }\n    }\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n  var remainingArgs = remaining.map(function (arg) {\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push.apply(categoryParts, _toConsumableArray(remainingArgs));\n  contentParts.push.apply(contentParts, _toConsumableArray(remainingArgs));\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets\n    }\n  };\n}\nfunction isComponentStack(consoleArgument) {\n  var isOldComponentStackFormat = / {4}in/.test(consoleArgument);\n  var isNewComponentStackFormat = / {4}at/.test(consoleArgument);\n  var isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\n  return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;\n}\nexport function parseComponentStack(message) {\n  var stack = parseErrorStack(message);\n  if (stack && stack.length > 0) {\n    return stack.map(function (frame) {\n      return {\n        content: frame.methodName,\n        collapse: frame.collapse || false,\n        fileName: frame.file == null ? 'unknown' : frame.file,\n        location: {\n          column: frame.column == null ? -1 : frame.column,\n          row: frame.lineNumber == null ? -1 : frame.lineNumber\n        }\n      };\n    });\n  }\n  return message.split(/\\n {4}in /g).map(function (s) {\n    if (!s) {\n      return null;\n    }\n    var match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n    if (!match) {\n      return null;\n    }\n    var _match$slice = match.slice(1),\n      _match$slice2 = _slicedToArray(_match$slice, 3),\n      content = _match$slice2[0],\n      fileName = _match$slice2[1],\n      row = _match$slice2[2];\n    return {\n      content: content,\n      fileName: fileName,\n      location: {\n        column: -1,\n        row: parseInt(row, 10)\n      }\n    };\n  }).filter(Boolean);\n}\nexport function parseLogBoxException(error) {\n  var message = error.originalMessage != null ? error.originalMessage : 'Unknown';\n  var metroInternalError = message.match(METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    var _metroInternalError$s = metroInternalError.slice(1),\n      _metroInternalError$s2 = _slicedToArray(_metroInternalError$s, 5),\n      content = _metroInternalError$s2[0],\n      fileName = _metroInternalError$s2[1],\n      row = _metroInternalError$s2[2],\n      column = _metroInternalError$s2[3],\n      codeFrame = _metroInternalError$s2[4];\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10)\n        },\n        content: codeFrame\n      },\n      message: {\n        content: content,\n        substitutions: []\n      },\n      category: fileName + \"-\" + row + \"-\" + column\n    };\n  }\n  var babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    var _babelTransformError$ = babelTransformError.slice(1),\n      _babelTransformError$2 = _slicedToArray(_babelTransformError$, 5),\n      _fileName = _babelTransformError$2[0],\n      _content = _babelTransformError$2[1],\n      _row = _babelTransformError$2[2],\n      _column = _babelTransformError$2[3],\n      _codeFrame = _babelTransformError$2[4];\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName,\n        location: {\n          row: parseInt(_row, 10),\n          column: parseInt(_column, 10)\n        },\n        content: _codeFrame\n      },\n      message: {\n        content: _content,\n        substitutions: []\n      },\n      category: _fileName + \"-\" + _row + \"-\" + _column\n    };\n  }\n  if (BABEL_CODE_FRAME_MARKER_PATTERN.test(message)) {\n    var babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n    if (babelCodeFrameError) {\n      var _babelCodeFrameError$ = babelCodeFrameError.slice(1),\n        _babelCodeFrameError$2 = _slicedToArray(_babelCodeFrameError$, 3),\n        _fileName2 = _babelCodeFrameError$2[0],\n        _content2 = _babelCodeFrameError$2[1],\n        _codeFrame2 = _babelCodeFrameError$2[2];\n      return {\n        level: 'syntax',\n        stack: [],\n        isComponentError: false,\n        componentStack: [],\n        codeFrame: {\n          fileName: _fileName2,\n          location: null,\n          content: _codeFrame2\n        },\n        message: {\n          content: _content2,\n          substitutions: []\n        },\n        category: _fileName2 + \"-\" + 1 + \"-\" + 1\n      };\n    }\n  }\n  if (message.match(/^TransformError /)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: []\n      },\n      category: message\n    };\n  }\n  var componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    return _objectSpread({\n      level: 'fatal',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: componentStack != null ? parseComponentStack(componentStack) : []\n    }, parseInterpolation([message]));\n  }\n  if (componentStack != null) {\n    return _objectSpread({\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack)\n    }, parseInterpolation([message]));\n  }\n  return _objectSpread({\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError\n  }, parseLogBoxLog([message]));\n}\nexport function parseLogBoxLog(args) {\n  var message = args[0];\n  var argsWithoutComponentStack = [];\n  var componentStack = [];\n  if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {\n    var lastArg = args[args.length - 1];\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n  if (componentStack.length === 0) {\n    for (var arg of args) {\n      if (typeof arg === 'string' && isComponentStack(arg)) {\n        var messageEndIndex = arg.search(/\\n {4}(in|at) /);\n        if (messageEndIndex < 0) {\n          messageEndIndex = arg.search(/\\n/);\n        }\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n  return _objectSpread(_objectSpread({}, parseInterpolation(argsWithoutComponentStack)), {}, {\n    componentStack: componentStack\n  });\n}","map":{"version":3,"names":["parseErrorStack","UTFSequence","stringifySafe","ansiRegex","ANSI_REGEX","source","BABEL_TRANSFORM_ERROR_FORMAT","BABEL_CODE_FRAME_MARKER_PATTERN","RegExp","join","BABEL_CODE_FRAME_ERROR_FORMAT","METRO_ERROR_FORMAT","SUBSTITUTION","BOM","parseInterpolation","args","categoryParts","contentParts","substitutionOffsets","remaining","_toConsumableArray","formatString","String","shift","formatStringParts","split","substitutionCount","length","substitutions","splice","categoryString","contentString","substitutionIndex","formatStringPart","substitution","push","offset","remainingArgs","map","arg","apply","category","message","content","isComponentStack","consoleArgument","isOldComponentStackFormat","test","isNewComponentStackFormat","isNewJSCComponentStackFormat","parseComponentStack","stack","frame","methodName","collapse","fileName","file","location","column","row","lineNumber","s","match","_match$slice","slice","_match$slice2","_slicedToArray","parseInt","filter","Boolean","parseLogBoxException","error","originalMessage","metroInternalError","_metroInternalError$s","_metroInternalError$s2","codeFrame","level","type","isComponentError","componentStack","babelTransformError","_babelTransformError$","_babelTransformError$2","babelCodeFrameError","_babelCodeFrameError$","_babelCodeFrameError$2","isFatal","_objectSpread","parseLogBoxLog","argsWithoutComponentStack","lastArg","messageEndIndex","search"],"sources":["E:/4 -ReactNative/Final-Year-Project/FYP3/AwesomeProject/node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\nimport type {ExceptionData} from '../../Core/NativeExceptionsManager';\r\nimport type {LogBoxLogData} from './LogBoxLog';\r\n\r\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\r\nimport UTFSequence from '../../UTFSequence';\r\nimport stringifySafe from '../../Utilities/stringifySafe';\r\nimport ansiRegex from 'ansi-regex';\r\n\r\nconst ANSI_REGEX = ansiRegex().source;\r\n\r\nconst BABEL_TRANSFORM_ERROR_FORMAT =\r\n  /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\r\n\r\n// https://github.com/babel/babel/blob/33dbb85e9e9fe36915273080ecc42aee62ed0ade/packages/babel-code-frame/src/index.ts#L183-L184\r\nconst BABEL_CODE_FRAME_MARKER_PATTERN = new RegExp(\r\n  [\r\n    // Beginning of a line (per 'm' flag)\r\n    '^',\r\n    // Optional ANSI escapes for colors\r\n    `(?:${ANSI_REGEX})*`,\r\n    // Marker\r\n    '>',\r\n    // Optional ANSI escapes for colors\r\n    `(?:${ANSI_REGEX})*`,\r\n    // Left padding for line number\r\n    ' +',\r\n    // Line number\r\n    '[0-9]+',\r\n    // Gutter\r\n    ' \\\\|',\r\n  ].join(''),\r\n  'm',\r\n);\r\n\r\nconst BABEL_CODE_FRAME_ERROR_FORMAT =\r\n  // eslint-disable-next-line no-control-regex\r\n  /^(?:TransformError )?(?:.*):? (?:.*?)(\\/.*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\r\n\r\nconst METRO_ERROR_FORMAT =\r\n  /^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/u;\r\n\r\nexport type ExtendedExceptionData = ExceptionData & {\r\n  isComponentError: boolean,\r\n  ...\r\n};\r\nexport type Category = string;\r\nexport type CodeFrame = $ReadOnly<{|\r\n  content: string,\r\n  location: ?{\r\n    row: number,\r\n    column: number,\r\n    ...\r\n  },\r\n  fileName: string,\r\n\r\n  // TODO: When React switched to using call stack frames,\r\n  // we gained the ability to use the collapse flag, but\r\n  // it is not integrated into the LogBox UI.\r\n  collapse?: boolean,\r\n|}>;\r\nexport type Message = $ReadOnly<{|\r\n  content: string,\r\n  substitutions: $ReadOnlyArray<\r\n    $ReadOnly<{|\r\n      length: number,\r\n      offset: number,\r\n    |}>,\r\n  >,\r\n|}>;\r\n\r\nexport type ComponentStack = $ReadOnlyArray<CodeFrame>;\r\n\r\nconst SUBSTITUTION = UTFSequence.BOM + '%s';\r\n\r\nexport function parseInterpolation(args: $ReadOnlyArray<mixed>): $ReadOnly<{|\r\n  category: Category,\r\n  message: Message,\r\n|}> {\r\n  const categoryParts = [];\r\n  const contentParts = [];\r\n  const substitutionOffsets = [];\r\n\r\n  const remaining = [...args];\r\n  if (typeof remaining[0] === 'string') {\r\n    const formatString = String(remaining.shift());\r\n    const formatStringParts = formatString.split('%s');\r\n    const substitutionCount = formatStringParts.length - 1;\r\n    const substitutions = remaining.splice(0, substitutionCount);\r\n\r\n    let categoryString = '';\r\n    let contentString = '';\r\n\r\n    let substitutionIndex = 0;\r\n    for (const formatStringPart of formatStringParts) {\r\n      categoryString += formatStringPart;\r\n      contentString += formatStringPart;\r\n\r\n      if (substitutionIndex < substitutionCount) {\r\n        if (substitutionIndex < substitutions.length) {\r\n          // Don't stringify a string type.\r\n          // It adds quotation mark wrappers around the string,\r\n          // which causes the LogBox to look odd.\r\n          const substitution =\r\n            typeof substitutions[substitutionIndex] === 'string'\r\n              ? substitutions[substitutionIndex]\r\n              : stringifySafe(substitutions[substitutionIndex]);\r\n          substitutionOffsets.push({\r\n            length: substitution.length,\r\n            offset: contentString.length,\r\n          });\r\n\r\n          categoryString += SUBSTITUTION;\r\n          contentString += substitution;\r\n        } else {\r\n          substitutionOffsets.push({\r\n            length: 2,\r\n            offset: contentString.length,\r\n          });\r\n\r\n          categoryString += '%s';\r\n          contentString += '%s';\r\n        }\r\n\r\n        substitutionIndex++;\r\n      }\r\n    }\r\n\r\n    categoryParts.push(categoryString);\r\n    contentParts.push(contentString);\r\n  }\r\n\r\n  const remainingArgs = remaining.map(arg => {\r\n    // Don't stringify a string type.\r\n    // It adds quotation mark wrappers around the string,\r\n    // which causes the LogBox to look odd.\r\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\r\n  });\r\n  categoryParts.push(...remainingArgs);\r\n  contentParts.push(...remainingArgs);\r\n\r\n  return {\r\n    category: categoryParts.join(' '),\r\n    message: {\r\n      content: contentParts.join(' '),\r\n      substitutions: substitutionOffsets,\r\n    },\r\n  };\r\n}\r\n\r\nfunction isComponentStack(consoleArgument: string) {\r\n  const isOldComponentStackFormat = / {4}in/.test(consoleArgument);\r\n  const isNewComponentStackFormat = / {4}at/.test(consoleArgument);\r\n  const isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\r\n\r\n  return (\r\n    isOldComponentStackFormat ||\r\n    isNewComponentStackFormat ||\r\n    isNewJSCComponentStackFormat\r\n  );\r\n}\r\n\r\nexport function parseComponentStack(message: string): ComponentStack {\r\n  // In newer versions of React, the component stack is formatted as a call stack frame.\r\n  // First try to parse the component stack as a call stack frame, and if that doesn't\r\n  // work then we'll fallback to the old custom component stack format parsing.\r\n  const stack = parseErrorStack(message);\r\n  if (stack && stack.length > 0) {\r\n    return stack.map(frame => ({\r\n      content: frame.methodName,\r\n      collapse: frame.collapse || false,\r\n      fileName: frame.file == null ? 'unknown' : frame.file,\r\n      location: {\r\n        column: frame.column == null ? -1 : frame.column,\r\n        row: frame.lineNumber == null ? -1 : frame.lineNumber,\r\n      },\r\n    }));\r\n  }\r\n\r\n  return message\r\n    .split(/\\n {4}in /g)\r\n    .map(s => {\r\n      if (!s) {\r\n        return null;\r\n      }\r\n      const match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\r\n      if (!match) {\r\n        return null;\r\n      }\r\n\r\n      let [content, fileName, row] = match.slice(1);\r\n      return {\r\n        content,\r\n        fileName,\r\n        location: {column: -1, row: parseInt(row, 10)},\r\n      };\r\n    })\r\n    .filter(Boolean);\r\n}\r\n\r\nexport function parseLogBoxException(\r\n  error: ExtendedExceptionData,\r\n): LogBoxLogData {\r\n  const message =\r\n    error.originalMessage != null ? error.originalMessage : 'Unknown';\r\n\r\n  const metroInternalError = message.match(METRO_ERROR_FORMAT);\r\n  if (metroInternalError) {\r\n    const [content, fileName, row, column, codeFrame] =\r\n      metroInternalError.slice(1);\r\n\r\n    return {\r\n      level: 'fatal',\r\n      type: 'Metro Error',\r\n      stack: [],\r\n      isComponentError: false,\r\n      componentStack: [],\r\n      codeFrame: {\r\n        fileName,\r\n        location: {\r\n          row: parseInt(row, 10),\r\n          column: parseInt(column, 10),\r\n        },\r\n        content: codeFrame,\r\n      },\r\n      message: {\r\n        content,\r\n        substitutions: [],\r\n      },\r\n      category: `${fileName}-${row}-${column}`,\r\n    };\r\n  }\r\n\r\n  const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\r\n  if (babelTransformError) {\r\n    // Transform errors are thrown from inside the Babel transformer.\r\n    const [fileName, content, row, column, codeFrame] =\r\n      babelTransformError.slice(1);\r\n\r\n    return {\r\n      level: 'syntax',\r\n      stack: [],\r\n      isComponentError: false,\r\n      componentStack: [],\r\n      codeFrame: {\r\n        fileName,\r\n        location: {\r\n          row: parseInt(row, 10),\r\n          column: parseInt(column, 10),\r\n        },\r\n        content: codeFrame,\r\n      },\r\n      message: {\r\n        content,\r\n        substitutions: [],\r\n      },\r\n      category: `${fileName}-${row}-${column}`,\r\n    };\r\n  }\r\n\r\n  // Perform a cheap match first before trying to parse the full message, which\r\n  // can get expensive for arbitrary input.\r\n  if (BABEL_CODE_FRAME_MARKER_PATTERN.test(message)) {\r\n    const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\r\n\r\n    if (babelCodeFrameError) {\r\n      // Codeframe errors are thrown from any use of buildCodeFrameError.\r\n      const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\r\n      return {\r\n        level: 'syntax',\r\n        stack: [],\r\n        isComponentError: false,\r\n        componentStack: [],\r\n        codeFrame: {\r\n          fileName,\r\n          location: null, // We are not given the location.\r\n          content: codeFrame,\r\n        },\r\n        message: {\r\n          content,\r\n          substitutions: [],\r\n        },\r\n        category: `${fileName}-${1}-${1}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  if (message.match(/^TransformError /)) {\r\n    return {\r\n      level: 'syntax',\r\n      stack: error.stack,\r\n      isComponentError: error.isComponentError,\r\n      componentStack: [],\r\n      message: {\r\n        content: message,\r\n        substitutions: [],\r\n      },\r\n      category: message,\r\n    };\r\n  }\r\n\r\n  const componentStack = error.componentStack;\r\n  if (error.isFatal || error.isComponentError) {\r\n    return {\r\n      level: 'fatal',\r\n      stack: error.stack,\r\n      isComponentError: error.isComponentError,\r\n      componentStack:\r\n        componentStack != null ? parseComponentStack(componentStack) : [],\r\n      ...parseInterpolation([message]),\r\n    };\r\n  }\r\n\r\n  if (componentStack != null) {\r\n    // It is possible that console errors have a componentStack.\r\n    return {\r\n      level: 'error',\r\n      stack: error.stack,\r\n      isComponentError: error.isComponentError,\r\n      componentStack: parseComponentStack(componentStack),\r\n      ...parseInterpolation([message]),\r\n    };\r\n  }\r\n\r\n  // Most `console.error` calls won't have a componentStack. We parse them like\r\n  // regular logs which have the component stack burried in the message.\r\n  return {\r\n    level: 'error',\r\n    stack: error.stack,\r\n    isComponentError: error.isComponentError,\r\n    ...parseLogBoxLog([message]),\r\n  };\r\n}\r\n\r\nexport function parseLogBoxLog(args: $ReadOnlyArray<mixed>): {|\r\n  componentStack: ComponentStack,\r\n  category: Category,\r\n  message: Message,\r\n|} {\r\n  const message = args[0];\r\n  let argsWithoutComponentStack: Array<mixed> = [];\r\n  let componentStack: ComponentStack = [];\r\n\r\n  // Extract component stack from warnings like \"Some warning%s\".\r\n  if (\r\n    typeof message === 'string' &&\r\n    message.slice(-2) === '%s' &&\r\n    args.length > 0\r\n  ) {\r\n    const lastArg = args[args.length - 1];\r\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\r\n      argsWithoutComponentStack = args.slice(0, -1);\r\n      argsWithoutComponentStack[0] = message.slice(0, -2);\r\n      componentStack = parseComponentStack(lastArg);\r\n    }\r\n  }\r\n\r\n  if (componentStack.length === 0) {\r\n    // Try finding the component stack elsewhere.\r\n    for (const arg of args) {\r\n      if (typeof arg === 'string' && isComponentStack(arg)) {\r\n        // Strip out any messages before the component stack.\r\n        let messageEndIndex = arg.search(/\\n {4}(in|at) /);\r\n        if (messageEndIndex < 0) {\r\n          // Handle JSC component stacks.\r\n          messageEndIndex = arg.search(/\\n/);\r\n        }\r\n        if (messageEndIndex > 0) {\r\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\r\n        }\r\n\r\n        componentStack = parseComponentStack(arg);\r\n      } else {\r\n        argsWithoutComponentStack.push(arg);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    ...parseInterpolation(argsWithoutComponentStack),\r\n    componentStack,\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}