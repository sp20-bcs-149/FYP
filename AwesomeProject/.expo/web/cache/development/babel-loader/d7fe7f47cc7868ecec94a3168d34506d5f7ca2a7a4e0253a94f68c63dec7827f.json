{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { lessThan, multiply, sub, add, divide, greaterThan, lessOrEq, eq } from \"../operators\";\nimport invariant from 'invariant';\nimport AnimatedNode from \"../core/AnimatedNode\";\nimport { createAnimatedCond as cond } from \"../core/AnimatedCond\";\nimport { createAnimatedFunction as proc } from \"../core/AnimatedFunction\";\nvar interpolateInternalSingleProc = proc(function (value, inS, inE, outS, outE) {\n  var progress = divide(sub(value, inS), sub(inE, inS));\n  var resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\n  var result = cond(eq(inS, inE), cond(lessOrEq(value, inS), outS, outE), resultForNonZeroRange);\n  return result;\n});\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\n  var inS = inputRange[offset];\n  var inE = inputRange[offset + 1];\n  var outS = outputRange[offset];\n  var outE = outputRange[offset + 1];\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\n}\nfunction interpolateInternal(value, inputRange, outputRange) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (inputRange.length - offset === 2) {\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\n  }\n  return cond(lessThan(value, inputRange[offset + 1]), interpolateInternalSingle(value, inputRange, outputRange, offset), interpolateInternal(value, inputRange, outputRange, offset + 1));\n}\nexport var Extrapolate = {\n  EXTEND: 'extend',\n  CLAMP: 'clamp',\n  IDENTITY: 'identity'\n};\nfunction checkNonDecreasing(name, arr) {\n  for (var i = 1; i < arr.length; ++i) {\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode) continue;\n    invariant(arr[i] >= arr[i - 1], '%s must be monotonically non-decreasing. (%s)', name, arr);\n  }\n}\nfunction checkMinElements(name, arr) {\n  invariant(arr.length >= 2, '%s must have at least 2 elements. (%s)', name, arr);\n}\nfunction checkValidNumbers(name, arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\n    invariant(Number.isFinite(arr[i]), '%s cannot include %s. (%s)', name, arr[i], arr);\n  }\n}\nfunction convertToRadians(outputRange) {\n  for (var _ref of outputRange.entries()) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    var i = _ref2[0];\n    var value = _ref2[1];\n    if (typeof value === 'string' && value.endsWith('deg')) {\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\n    } else if (typeof value === 'string' && value.endsWith('rad')) {\n      outputRange[i] = parseFloat(value);\n    }\n  }\n}\nexport default function interpolate(value, config) {\n  var inputRange = config.inputRange,\n    outputRange = config.outputRange,\n    _config$extrapolate = config.extrapolate,\n    extrapolate = _config$extrapolate === void 0 ? Extrapolate.EXTEND : _config$extrapolate,\n    extrapolateLeft = config.extrapolateLeft,\n    extrapolateRight = config.extrapolateRight;\n  checkMinElements('inputRange', inputRange);\n  checkValidNumbers('inputRange', inputRange);\n  checkMinElements('outputRange', outputRange);\n  checkValidNumbers('outputRange', outputRange);\n  checkNonDecreasing('inputRange', inputRange);\n  invariant(inputRange.length === outputRange.length, 'inputRange and outputRange must be the same length.');\n  convertToRadians(outputRange);\n  var left = extrapolateLeft || extrapolate;\n  var right = extrapolateRight || extrapolate;\n  var output = interpolateInternal(value, inputRange, outputRange);\n  if (left === Extrapolate.CLAMP) {\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\n  } else if (left === Extrapolate.IDENTITY) {\n    output = cond(lessThan(value, inputRange[0]), value, output);\n  }\n  if (right === Extrapolate.CLAMP) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), outputRange[outputRange.length - 1], output);\n  } else if (right === Extrapolate.IDENTITY) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), value, output);\n  }\n  return output;\n}","map":{"version":3,"names":["lessThan","multiply","sub","add","divide","greaterThan","lessOrEq","eq","invariant","AnimatedNode","createAnimatedCond","cond","createAnimatedFunction","proc","interpolateInternalSingleProc","value","inS","inE","outS","outE","progress","resultForNonZeroRange","result","interpolateInternalSingle","inputRange","outputRange","offset","interpolateInternal","arguments","length","undefined","Extrapolate","EXTEND","CLAMP","IDENTITY","checkNonDecreasing","name","arr","i","checkMinElements","checkValidNumbers","Number","isFinite","convertToRadians","_ref","entries","_ref2","_slicedToArray","endsWith","parseFloat","Math","PI","interpolate","config","_config$extrapolate","extrapolate","extrapolateLeft","extrapolateRight","left","right","output"],"sources":["E:/4 -ReactNative/Final-Year-Project/FYP3/AwesomeProject/node_modules/react-native-reanimated/lib/reanimated1/derived/interpolate.js"],"sourcesContent":["import {\r\n  lessThan,\r\n  multiply,\r\n  sub,\r\n  add,\r\n  divide,\r\n  greaterThan,\r\n  lessOrEq,\r\n  eq,\r\n} from '../operators';\r\nimport invariant from 'invariant';\r\n\r\nimport AnimatedNode from '../core/AnimatedNode';\r\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\r\nimport { createAnimatedFunction as proc } from '../core/AnimatedFunction';\r\n\r\nconst interpolateInternalSingleProc = proc(function (\r\n  value,\r\n  inS,\r\n  inE,\r\n  outS,\r\n  outE\r\n) {\r\n  const progress = divide(sub(value, inS), sub(inE, inS));\r\n  // logic below was made in order to provide a compatibility witn an Animated API\r\n  const resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\r\n  const result = cond(\r\n    eq(inS, inE),\r\n    cond(lessOrEq(value, inS), outS, outE),\r\n    resultForNonZeroRange\r\n  );\r\n  return result;\r\n});\r\n\r\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\r\n  const inS = inputRange[offset];\r\n  const inE = inputRange[offset + 1];\r\n  const outS = outputRange[offset];\r\n  const outE = outputRange[offset + 1];\r\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\r\n}\r\n\r\nfunction interpolateInternal(value, inputRange, outputRange, offset = 0) {\r\n  if (inputRange.length - offset === 2) {\r\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\r\n  }\r\n  return cond(\r\n    lessThan(value, inputRange[offset + 1]),\r\n    interpolateInternalSingle(value, inputRange, outputRange, offset),\r\n    interpolateInternal(value, inputRange, outputRange, offset + 1)\r\n  );\r\n}\r\n\r\nexport const Extrapolate = {\r\n  EXTEND: 'extend',\r\n  CLAMP: 'clamp',\r\n  IDENTITY: 'identity',\r\n};\r\n\r\nfunction checkNonDecreasing(name, arr) {\r\n  for (let i = 1; i < arr.length; ++i) {\r\n    // We can't validate animated nodes in JS.\r\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode)\r\n      continue;\r\n    invariant(\r\n      arr[i] >= arr[i - 1],\r\n      '%s must be monotonically non-decreasing. (%s)',\r\n      name,\r\n      arr\r\n    );\r\n  }\r\n}\r\n\r\nfunction checkMinElements(name, arr) {\r\n  invariant(\r\n    arr.length >= 2,\r\n    '%s must have at least 2 elements. (%s)',\r\n    name,\r\n    arr\r\n  );\r\n}\r\n\r\nfunction checkValidNumbers(name, arr) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    // We can't validate animated nodes in JS.\r\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\r\n    invariant(\r\n      Number.isFinite(arr[i]),\r\n      '%s cannot include %s. (%s)',\r\n      name,\r\n      arr[i],\r\n      arr\r\n    );\r\n  }\r\n}\r\n\r\nfunction convertToRadians(outputRange) {\r\n  for (const [i, value] of outputRange.entries()) {\r\n    if (typeof value === 'string' && value.endsWith('deg')) {\r\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\r\n    } else if (typeof value === 'string' && value.endsWith('rad')) {\r\n      outputRange[i] = parseFloat(value);\r\n    }\r\n  }\r\n}\r\n\r\nexport default function interpolate(value, config) {\r\n  const {\r\n    inputRange,\r\n    outputRange,\r\n    extrapolate = Extrapolate.EXTEND,\r\n    extrapolateLeft,\r\n    extrapolateRight,\r\n  } = config;\r\n\r\n  checkMinElements('inputRange', inputRange);\r\n  checkValidNumbers('inputRange', inputRange);\r\n  checkMinElements('outputRange', outputRange);\r\n  checkValidNumbers('outputRange', outputRange);\r\n  checkNonDecreasing('inputRange', inputRange);\r\n  invariant(\r\n    inputRange.length === outputRange.length,\r\n    'inputRange and outputRange must be the same length.'\r\n  );\r\n\r\n  convertToRadians(outputRange);\r\n  const left = extrapolateLeft || extrapolate;\r\n  const right = extrapolateRight || extrapolate;\r\n  let output = interpolateInternal(value, inputRange, outputRange);\r\n\r\n  if (left === Extrapolate.CLAMP) {\r\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\r\n  } else if (left === Extrapolate.IDENTITY) {\r\n    output = cond(lessThan(value, inputRange[0]), value, output);\r\n  }\r\n\r\n  if (right === Extrapolate.CLAMP) {\r\n    output = cond(\r\n      greaterThan(value, inputRange[inputRange.length - 1]),\r\n      outputRange[outputRange.length - 1],\r\n      output\r\n    );\r\n  } else if (right === Extrapolate.IDENTITY) {\r\n    output = cond(\r\n      greaterThan(value, inputRange[inputRange.length - 1]),\r\n      value,\r\n      output\r\n    );\r\n  }\r\n\r\n  return output;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}