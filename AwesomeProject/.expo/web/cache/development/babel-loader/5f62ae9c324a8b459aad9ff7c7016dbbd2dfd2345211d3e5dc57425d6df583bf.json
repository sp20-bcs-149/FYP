{"ast":null,"code":"'use strict';\n\nvar RE_FRAME = /^ {4}at (.+?)(?: \\((native)\\)?| \\((address at )?(.*?):(\\d+):(\\d+)\\))$/;\nvar RE_SKIPPED = /^ {4}... skipping (\\d+) frames$/;\nfunction parseLine(line) {\n  var asFrame = line.match(RE_FRAME);\n  if (asFrame) {\n    return {\n      type: 'FRAME',\n      functionName: asFrame[1],\n      location: asFrame[2] === 'native' ? {\n        type: 'NATIVE'\n      } : asFrame[3] === 'address at ' ? {\n        type: 'BYTECODE',\n        sourceUrl: asFrame[4],\n        line1Based: Number.parseInt(asFrame[5], 10),\n        virtualOffset0Based: Number.parseInt(asFrame[6], 10)\n      } : {\n        type: 'SOURCE',\n        sourceUrl: asFrame[4],\n        line1Based: Number.parseInt(asFrame[5], 10),\n        column1Based: Number.parseInt(asFrame[6], 10)\n      }\n    };\n  }\n  var asSkipped = line.match(RE_SKIPPED);\n  if (asSkipped) {\n    return {\n      type: 'SKIPPED',\n      count: Number.parseInt(asSkipped[1], 10)\n    };\n  }\n}\nmodule.exports = function parseHermesStack(stack) {\n  var lines = stack.split(/\\n/);\n  var entries = [];\n  var lastMessageLine = -1;\n  for (var i = 0; i < lines.length; ++i) {\n    var line = lines[i];\n    if (!line) {\n      continue;\n    }\n    var entry = parseLine(line);\n    if (entry) {\n      entries.push(entry);\n      continue;\n    }\n    lastMessageLine = i;\n    entries = [];\n  }\n  var message = lines.slice(0, lastMessageLine + 1).join('\\n');\n  return {\n    message: message,\n    entries: entries\n  };\n};","map":{"version":3,"names":["RE_FRAME","RE_SKIPPED","parseLine","line","asFrame","match","type","functionName","location","sourceUrl","line1Based","Number","parseInt","virtualOffset0Based","column1Based","asSkipped","count","module","exports","parseHermesStack","stack","lines","split","entries","lastMessageLine","i","length","entry","push","message","slice","join"],"sources":["E:/4 -ReactNative/Final-Year-Project/FYP3/AwesomeProject/node_modules/react-native/Libraries/Core/Devtools/parseHermesStack.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * @flow strict\r\n */\r\n\r\n'use strict';\r\n\r\ntype HermesStackLocationNative = {|\r\n  +type: 'NATIVE',\r\n|};\r\n\r\ntype HermesStackLocationSource = {|\r\n  +type: 'SOURCE',\r\n  +sourceUrl: string,\r\n  +line1Based: number,\r\n  +column1Based: number,\r\n|};\r\n\r\ntype HermesStackLocationBytecode = {|\r\n  +type: 'BYTECODE',\r\n  +sourceUrl: string,\r\n  +line1Based: number,\r\n  +virtualOffset0Based: number,\r\n|};\r\n\r\ntype HermesStackLocation =\r\n  | HermesStackLocationNative\r\n  | HermesStackLocationSource\r\n  | HermesStackLocationBytecode;\r\n\r\ntype HermesStackEntryFrame = {|\r\n  +type: 'FRAME',\r\n  +location: HermesStackLocation,\r\n  +functionName: string,\r\n|};\r\n\r\ntype HermesStackEntrySkipped = {|\r\n  +type: 'SKIPPED',\r\n  +count: number,\r\n|};\r\n\r\ntype HermesStackEntry = HermesStackEntryFrame | HermesStackEntrySkipped;\r\n\r\nexport type HermesParsedStack = {|\r\n  +message: string,\r\n  +entries: $ReadOnlyArray<HermesStackEntry>,\r\n|};\r\n\r\n// Capturing groups:\r\n// 1. function name\r\n// 2. is this a native stack frame?\r\n// 3. is this a bytecode address or a source location?\r\n// 4. source URL (filename)\r\n// 5. line number (1 based)\r\n// 6. column number (1 based) or virtual offset (0 based)\r\nconst RE_FRAME =\r\n  /^ {4}at (.+?)(?: \\((native)\\)?| \\((address at )?(.*?):(\\d+):(\\d+)\\))$/;\r\n\r\n// Capturing groups:\r\n// 1. count of skipped frames\r\nconst RE_SKIPPED = /^ {4}... skipping (\\d+) frames$/;\r\n\r\nfunction parseLine(line: string): ?HermesStackEntry {\r\n  const asFrame = line.match(RE_FRAME);\r\n  if (asFrame) {\r\n    return {\r\n      type: 'FRAME',\r\n      functionName: asFrame[1],\r\n      location:\r\n        asFrame[2] === 'native'\r\n          ? {type: 'NATIVE'}\r\n          : asFrame[3] === 'address at '\r\n          ? {\r\n              type: 'BYTECODE',\r\n              sourceUrl: asFrame[4],\r\n              line1Based: Number.parseInt(asFrame[5], 10),\r\n              virtualOffset0Based: Number.parseInt(asFrame[6], 10),\r\n            }\r\n          : {\r\n              type: 'SOURCE',\r\n              sourceUrl: asFrame[4],\r\n              line1Based: Number.parseInt(asFrame[5], 10),\r\n              column1Based: Number.parseInt(asFrame[6], 10),\r\n            },\r\n    };\r\n  }\r\n  const asSkipped = line.match(RE_SKIPPED);\r\n  if (asSkipped) {\r\n    return {\r\n      type: 'SKIPPED',\r\n      count: Number.parseInt(asSkipped[1], 10),\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = function parseHermesStack(stack: string): HermesParsedStack {\r\n  const lines = stack.split(/\\n/);\r\n  let entries: Array<HermesStackEntryFrame | HermesStackEntrySkipped> = [];\r\n  let lastMessageLine = -1;\r\n  for (let i = 0; i < lines.length; ++i) {\r\n    const line = lines[i];\r\n    if (!line) {\r\n      continue;\r\n    }\r\n    const entry = parseLine(line);\r\n    if (entry) {\r\n      entries.push(entry);\r\n      continue;\r\n    }\r\n    // No match - we're still in the message\r\n    lastMessageLine = i;\r\n    entries = [];\r\n  }\r\n  const message = lines.slice(0, lastMessageLine + 1).join('\\n');\r\n  return {message, entries};\r\n};\r\n"],"mappings":"AAUA,YAAY;;AAkDZ,IAAMA,QAAQ,GACZ,uEAAuE;AAIzE,IAAMC,UAAU,GAAG,iCAAiC;AAEpD,SAASC,SAASA,CAACC,IAAY,EAAqB;EAClD,IAAMC,OAAO,GAAGD,IAAI,CAACE,KAAK,CAACL,QAAQ,CAAC;EACpC,IAAII,OAAO,EAAE;IACX,OAAO;MACLE,IAAI,EAAE,OAAO;MACbC,YAAY,EAAEH,OAAO,CAAC,CAAC,CAAC;MACxBI,QAAQ,EACNJ,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,GACnB;QAACE,IAAI,EAAE;MAAQ,CAAC,GAChBF,OAAO,CAAC,CAAC,CAAC,KAAK,aAAa,GAC5B;QACEE,IAAI,EAAE,UAAU;QAChBG,SAAS,EAAEL,OAAO,CAAC,CAAC,CAAC;QACrBM,UAAU,EAAEC,MAAM,CAACC,QAAQ,CAACR,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QAC3CS,mBAAmB,EAAEF,MAAM,CAACC,QAAQ,CAACR,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;MACrD,CAAC,GACD;QACEE,IAAI,EAAE,QAAQ;QACdG,SAAS,EAAEL,OAAO,CAAC,CAAC,CAAC;QACrBM,UAAU,EAAEC,MAAM,CAACC,QAAQ,CAACR,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QAC3CU,YAAY,EAAEH,MAAM,CAACC,QAAQ,CAACR,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;MAC9C;IACR,CAAC;EACH;EACA,IAAMW,SAAS,GAAGZ,IAAI,CAACE,KAAK,CAACJ,UAAU,CAAC;EACxC,IAAIc,SAAS,EAAE;IACb,OAAO;MACLT,IAAI,EAAE,SAAS;MACfU,KAAK,EAAEL,MAAM,CAACC,QAAQ,CAACG,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE;IACzC,CAAC;EACH;AACF;AAEAE,MAAM,CAACC,OAAO,GAAG,SAASC,gBAAgBA,CAACC,KAAa,EAAqB;EAC3E,IAAMC,KAAK,GAAGD,KAAK,CAACE,KAAK,CAAC,IAAI,CAAC;EAC/B,IAAIC,OAA+D,GAAG,EAAE;EACxE,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;IACrC,IAAMtB,IAAI,GAAGkB,KAAK,CAACI,CAAC,CAAC;IACrB,IAAI,CAACtB,IAAI,EAAE;MACT;IACF;IACA,IAAMwB,KAAK,GAAGzB,SAAS,CAACC,IAAI,CAAC;IAC7B,IAAIwB,KAAK,EAAE;MACTJ,OAAO,CAACK,IAAI,CAACD,KAAK,CAAC;MACnB;IACF;IAEAH,eAAe,GAAGC,CAAC;IACnBF,OAAO,GAAG,EAAE;EACd;EACA,IAAMM,OAAO,GAAGR,KAAK,CAACS,KAAK,CAAC,CAAC,EAAEN,eAAe,GAAG,CAAC,CAAC,CAACO,IAAI,CAAC,IAAI,CAAC;EAC9D,OAAO;IAACF,OAAO,EAAPA,OAAO;IAAEN,OAAO,EAAPA;EAAO,CAAC;AAC3B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}